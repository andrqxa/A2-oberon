MODULE FoxDocumentationBackend;
	IMPORT Basic := FoxBasic, SyntaxTree := FoxSyntaxTree, Global := FoxGlobal, Scanner := FoxScanner, Backend := FoxBackend, Formats := FoxFormats, Options, Streams, Strings, SymbolFileFormat := FoxTextualSymbolFile, Diagnostics, DocumentationTree := FoxDocumentationTree, DocumentationPrinter := FoxDocumentationPrinter, DocumentationHtml := FoxDocumentationHtml, DocumentationParser := FoxDocumentationParser, DocumentationScanner := FoxDocumentationScanner, D := Debugging, Files;
CONST 
	Section = 0; 
	Item = 1; 
	Enum = 2; 
	MaxLevels = 3; 
	VisibleConstant* = 3; 
	SecondVisibleConstant* = 4; 
	Third* = 4; 
	DefaultTemplateFile = \"FoxDocumentationTemplate.txt"\; 
	KeywordElementType = ElementType.Bold; 
	QualifiedIdentifierElementType = ElementType.Bold; 
TYPE 
	ElementType = DocumentationTree.ElementType; 

	ParagraphType = DocumentationTree.ParagraphType; 

	State = RECORD 
		document: DocumentationTree.Document; 
		section: DocumentationTree.Section; 
		paragraphs: DocumentationTree.Paragraphs; 
		paragraph: DocumentationTree.Paragraph; 
		text: DocumentationTree.Text; 
		scope: SyntaxTree.Scope; 
	END; 

	Generator* = OBJECT (SyntaxTree.Visitor)
	VAR 
		w, ws: Streams.StringWriter; 
		case: SIGNED32; 
		diagnostics: Diagnostics.Diagnostics; 
		level: ARRAY MaxLevels OF SIGNED32; 
		current: State; 
		document: DocumentationTree.Document; 
		parameterDocument: DocumentationTree.Document; 
		short: BOOLEAN; 
		backend: DocumentationBackend; 

		PROCEDURE ^  & Init*(diagnostics: Diagnostics.Diagnostics); 
		PROCEDURE ^ Keyword(CONST a: ARRAY OF CHAR); 
		PROCEDURE ^ Identifier*(x: SyntaxTree.Identifier); 
		PROCEDURE ^ QualifiedIdentifier*(x: SyntaxTree.QualifiedIdentifier); 
		PROCEDURE ^ Type*(x: SyntaxTree.Type); 
		PROCEDURE ^ {OVERRIDE} VisitType*(x: SyntaxTree.Type); 
		PROCEDURE ^ {OVERRIDE} VisitBasicType*(x: SyntaxTree.BasicType); 
		PROCEDURE ^ {OVERRIDE} VisitBooleanType*(x: SyntaxTree.BooleanType); 
		PROCEDURE ^ {OVERRIDE} VisitSetType*(x: SyntaxTree.SetType); 
		PROCEDURE ^ {OVERRIDE} VisitSizeType*(x: SyntaxTree.SizeType); 
		PROCEDURE ^ {OVERRIDE} VisitCharacterType*(x: SyntaxTree.CharacterType); 
		PROCEDURE ^ {OVERRIDE} VisitIntegerType*(x: SyntaxTree.IntegerType); 
		PROCEDURE ^ {OVERRIDE} VisitFloatType*(x: SyntaxTree.FloatType); 
		PROCEDURE ^ {OVERRIDE} VisitComplexType*(x: SyntaxTree.ComplexType); 
		PROCEDURE ^ {OVERRIDE} VisitByteType*(x: SyntaxTree.ByteType); 
		PROCEDURE ^ {OVERRIDE} VisitQualifiedType*(x: SyntaxTree.QualifiedType); 
		PROCEDURE ^ {OVERRIDE} VisitStringType*(x: SyntaxTree.StringType); 
		PROCEDURE ^ {OVERRIDE} VisitEnumerationType*(x: SyntaxTree.EnumerationType); 
		PROCEDURE ^ {OVERRIDE} VisitRangeType*(x: SyntaxTree.RangeType); 
		PROCEDURE ^ {OVERRIDE} VisitArrayType*(x: SyntaxTree.ArrayType); 
		PROCEDURE ^ {OVERRIDE} VisitNilType*(x: SyntaxTree.NilType); 
		PROCEDURE ^ {OVERRIDE} VisitAddressType*(x: SyntaxTree.AddressType); 
		PROCEDURE ^ {OVERRIDE} VisitObjectType*(x: SyntaxTree.ObjectType); 
		PROCEDURE ^ {OVERRIDE} VisitAnyType*(x: SyntaxTree.AnyType); 
		PROCEDURE ^ {OVERRIDE} VisitMathArrayType*(x: SyntaxTree.MathArrayType); 
		PROCEDURE ^ {OVERRIDE} VisitPointerType*(x: SyntaxTree.PointerType); 
		PROCEDURE ^ {OVERRIDE} VisitPortType*(x: SyntaxTree.PortType); 
		PROCEDURE ^ {OVERRIDE} VisitCellType*(x: SyntaxTree.CellType); 
		PROCEDURE ^ {OVERRIDE} VisitRecordType*(x: SyntaxTree.RecordType); 
		PROCEDURE ^ {OVERRIDE} VisitProcedureType*(x: SyntaxTree.ProcedureType); 
		PROCEDURE ^ ExpressionList(x: SyntaxTree.ExpressionList); 
		PROCEDURE ^ Expression*(x: SyntaxTree.Expression); 
		PROCEDURE ^ {OVERRIDE} VisitExpression*(x: SyntaxTree.Expression); 
		PROCEDURE ^ {OVERRIDE} VisitSet*(x: SyntaxTree.Set); 
		PROCEDURE ^ {OVERRIDE} VisitMathArrayExpression*(x: SyntaxTree.MathArrayExpression); 
		PROCEDURE ^ {OVERRIDE} VisitUnaryExpression*(x: SyntaxTree.UnaryExpression); 
		PROCEDURE ^ {OVERRIDE} VisitBinaryExpression*(x: SyntaxTree.BinaryExpression); 
		PROCEDURE ^ {OVERRIDE} VisitRangeExpression*(x: SyntaxTree.RangeExpression); 
		PROCEDURE ^ {OVERRIDE} VisitTensorRangeExpression*(x: SyntaxTree.TensorRangeExpression); 
		PROCEDURE ^ {OVERRIDE} VisitConversion*(x: SyntaxTree.Conversion); 
		PROCEDURE ^ {OVERRIDE} VisitSymbolDesignator*(x: SyntaxTree.SymbolDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitBuiltinCallDesignator*(x: SyntaxTree.BuiltinCallDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitValue*(x: SyntaxTree.Value); 
		PROCEDURE ^ {OVERRIDE} VisitBooleanValue*(x: SyntaxTree.BooleanValue); 
		PROCEDURE ^ {OVERRIDE} VisitIntegerValue*(x: SyntaxTree.IntegerValue); 
		PROCEDURE ^ {OVERRIDE} VisitCharacterValue*(x: SyntaxTree.CharacterValue); 
		PROCEDURE ^ {OVERRIDE} VisitSetValue*(x: SyntaxTree.SetValue); 
		PROCEDURE ^ {OVERRIDE} VisitMathArrayValue*(x: SyntaxTree.MathArrayValue); 
		PROCEDURE ^ FormatedFloat(value: FLOAT64; subtype: SIGNED32); 
		PROCEDURE ^ {OVERRIDE} VisitRealValue*(x: SyntaxTree.RealValue); 
		PROCEDURE ^ {OVERRIDE} VisitComplexValue*(x: SyntaxTree.ComplexValue); 
		PROCEDURE ^ {OVERRIDE} VisitStringValue*(x: SyntaxTree.StringValue); 
		PROCEDURE ^ {OVERRIDE} VisitNilValue*(x: SyntaxTree.NilValue); 
		PROCEDURE ^ {OVERRIDE} VisitEnumerationValue*(x: SyntaxTree.EnumerationValue); 
		PROCEDURE ^ {OVERRIDE} VisitParameter*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ PrintSymbol(x: SyntaxTree.Symbol); 
		PROCEDURE ^ ParameterList*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ Visible(symbol: SyntaxTree.Symbol): BOOLEAN; 
		PROCEDURE ^ Symbol*(x: SyntaxTree.Symbol); 
		PROCEDURE ^ NeedsSection(x: SyntaxTree.Symbol): BOOLEAN; 
		PROCEDURE ^ ExtractParameters(x: SyntaxTree.ProcedureType; doc: DocumentationTree.Document; VAR parameters: DocumentationTree.Document); 
		PROCEDURE ^ WriteSymbolSection(x: SyntaxTree.Symbol); 
		PROCEDURE ^ BeginSymbolSection(CONST title: ARRAY OF CHAR; x: SyntaxTree.Symbol): DocumentationTree.Section; 
		PROCEDURE ^ {OVERRIDE} VisitSymbol*(x: SyntaxTree.Symbol); 
		PROCEDURE ^ {OVERRIDE} VisitTypeDeclaration*(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ {OVERRIDE} VisitConstant*(x: SyntaxTree.Constant); 
		PROCEDURE ^ {OVERRIDE} VisitVariable*(x: SyntaxTree.Variable); 
		PROCEDURE ^ Flag(identifier: SyntaxTree.Identifier; VAR first: BOOLEAN); 
		PROCEDURE ^ FlagEnd(first: BOOLEAN); 
		PROCEDURE ^ Int(value: SIGNED32); 
		PROCEDURE ^ Value(identifier: SyntaxTree.Identifier; value: SIZE; VAR first: BOOLEAN); 
		PROCEDURE ^ {OVERRIDE} VisitProcedure*(x: SyntaxTree.Procedure); 
		PROCEDURE ^ String(CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ Whitespace; 
		PROCEDURE ^ {OVERRIDE} VisitOperator*(x: SyntaxTree.Operator); 
		PROCEDURE ^ {OVERRIDE} VisitImport*(x: SyntaxTree.Import); 
		PROCEDURE ^ {OVERRIDE} VisitBuiltin*(x: SyntaxTree.Builtin); 
		PROCEDURE ^ Scope*(x: SyntaxTree.Scope); 
		PROCEDURE ^ SymbolRow(CONST head: ARRAY OF CHAR; symbol: SyntaxTree.Symbol; VAR first: BOOLEAN); 
		PROCEDURE ^ Summary(paragraphs: DocumentationTree.Paragraphs; x: SyntaxTree.Scope); 
		PROCEDURE ^ WriteTextElement(textElement: DocumentationTree.TextElement); 
		PROCEDURE ^ BeginSection(document: DocumentationTree.Document): DocumentationTree.Section; 
		PROCEDURE ^ PrefixSection(document: DocumentationTree.Document): DocumentationTree.Section; 
		PROCEDURE ^ EndSection(section: DocumentationTree.Section); 
		PROCEDURE ^ PatchLinkE(element: DocumentationTree.TextElement); 
		PROCEDURE ^ PatchLinksP(par: DocumentationTree.Paragraph); 
		PROCEDURE ^ PatchLinksS(sec: DocumentationTree.Section); 
		PROCEDURE ^ PatchLinks(doc: DocumentationTree.Document; scope: SyntaxTree.Scope); 
		PROCEDURE ^ Modifiers(x: SyntaxTree.Modifier); 
		PROCEDURE ^ Module*(x: SyntaxTree.Module; backend: DocumentationBackend): DocumentationTree.Document; 
	END Generator; 

	Checker = OBJECT 
	VAR 
		labels: DocumentationTree.Text; 
		links: DocumentationTree.Text; 
		currentScope: SyntaxTree.Scope; 

		PROCEDURE ^ CheckElement(element: DocumentationTree.TextElement); 
		PROCEDURE ^ CollectElement(element: DocumentationTree.TextElement); 
		PROCEDURE ^ CollectParagraph(par: DocumentationTree.Paragraph); 
		PROCEDURE ^ CollectSection(sec: DocumentationTree.Section); 
		PROCEDURE ^ Document(doc: DocumentationTree.Document; scope: SyntaxTree.Scope); 
	END Checker; 

	DocumentationBackend = OBJECT (Backend.Backend)
	VAR 
		trace: BOOLEAN; 
		fileName: Files.FileName; 
		generator: Generator; 
		templateFile: Files.FileName; 
		internals: BOOLEAN; 

		PROCEDURE ^  & InitIntermediateBackend*; 
		PROCEDURE ^ ParseFile(fileName: ARRAY OF CHAR): DocumentationTree.Document; 
		PROCEDURE ^ {OVERRIDE} ProcessSyntaxTreeModule*(syntaxTreeModule: SyntaxTree.Module): Formats.GeneratedModule; 
		PROCEDURE ^ {OVERRIDE} DefineOptions*(options: Options.Options); 
		PROCEDURE ^ {OVERRIDE} GetOptions*(options: Options.Options); 
		PROCEDURE ^ {OVERRIDE} DefaultSymbolFileFormat*(): Formats.SymbolFileFormat; 
		PROCEDURE ^ {OVERRIDE} DefaultObjectFileFormat*(): Formats.ObjectFileFormat; 
	END DocumentationBackend; 

	PROCEDURE ^ Small(CONST name: ARRAY OF CHAR; VAR result: ARRAY OF CHAR); 
	PROCEDURE ^ Hex(w: Streams.Writer; x: SIGNED64); 
	PROCEDURE ^ ToText(w: Streams.StringWriter; text: DocumentationTree.Text; elementType: ElementType); 
	PROCEDURE ^ WriteSymbolLabel(text: DocumentationTree.Text; symbol: SyntaxTree.Symbol); 
	PROCEDURE ^ WriteReferenceInScope*(text: DocumentationTree.Text; symbol: SyntaxTree.Symbol; inScope: SyntaxTree.Scope); 
	PROCEDURE ^ WriteSymbolReference(text: DocumentationTree.Text; symbol: SyntaxTree.Symbol; scope: SyntaxTree.Scope); 
	PROCEDURE ^ ParseComments(document: DocumentationTree.Document; c, sentinel: SyntaxTree.Comment; x: ANY ); 
	PROCEDURE ^ MergeComments(c, sentinel: SyntaxTree.Comment; x: ANY ): DocumentationTree.String; 
	PROCEDURE ^ KeepSections(in: DocumentationTree.Document); 
	PROCEDURE ^ MergeDocument(in: DocumentationTree.Document; descriptionSection: DocumentationTree.Paragraphs; this: DocumentationTree.Document); 
	PROCEDURE ^ MergeParagraphs(in, this: DocumentationTree.Paragraphs); 
	PROCEDURE ^ MergeSections(in, this: DocumentationTree.Sections); 
	PROCEDURE ^ MergeSectionDocument(section: DocumentationTree.Section; document: DocumentationTree.Document); 
	PROCEDURE ^ Get*(): Backend.Backend; 
BEGIN
END FoxDocumentationBackend.
