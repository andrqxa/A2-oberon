MODULE FoxInterpreter;
	IMPORT Scanner := FoxScanner, FoxParser, SyntaxTree := FoxSyntaxTree, Printout := FoxPrintout, Commands, Diagnostics, StringPool, InterpreterSymbols := FoxInterpreterSymbols, D := Debugging, Strings, Streams, Modules, PersistentObjects, Basic := FoxBasic, SYSTEM, Machine, Global := FoxGlobal, Heaps;
CONST 
	EnableTrace = FALSE; 
	MaxIndex = 8; 
TYPE 
	Result* = InterpreterSymbols.Result; 

	Value* = InterpreterSymbols.Value; 

	Integer* = InterpreterSymbols.IntegerValue; 

	Real* = InterpreterSymbols.RealValue; 

	String* = InterpreterSymbols.StringValue; 

	Boolean* = InterpreterSymbols.BooleanValue; 

	Set* = InterpreterSymbols.SetValue; 

	Range* = InterpreterSymbols.RangeValue; 

	Char* = InterpreterSymbols.CharValue; 

	Any* = InterpreterSymbols.AnyValue; 

	MathArrayValue* = InterpreterSymbols.MathArrayValue; 

	Scope* = InterpreterSymbols.Scope; 

	Container* = InterpreterSymbols.Container; 

	Builtin* = OBJECT (InterpreterSymbols.Object)
	VAR 
		id: SIGNED32; 
	END Builtin; 

	Item* = RECORD 
		object*: InterpreterSymbols.Item; 
		in*: InterpreterSymbols.Item; 
		name*: StringPool.Index; 
		i*: ARRAY MaxIndex OF SIGNED32; 
	END; 

	CommandStatement = OBJECT (SyntaxTree.Statement)
	VAR 
		command: Strings.String; 

		PROCEDURE ^  & InitCommandStatement(s: Strings.String); 
	END CommandStatement; 

	PrintStatement = OBJECT (SyntaxTree.Statement)
	VAR 
		expression: SyntaxTree.Expression; 

		PROCEDURE ^  & InitPrintStatement(e: SyntaxTree.Expression); 
	END PrintStatement; 

	Parser* = OBJECT (FoxParser.Parser)

		PROCEDURE ^ {OVERRIDE} Statement*(statements: SyntaxTree.StatementSequence; outer: SyntaxTree.Statement): BOOLEAN; 
		PROCEDURE ^ Cmd(): SyntaxTree.Statement; 
		PROCEDURE ^ Print(): SyntaxTree.Statement; 
	END Parser; 

	Interpreter* = OBJECT (SyntaxTree.Visitor)
	VAR 
		value: BOOLEAN; 
		item-: Item; 
		module-: Modules.Module; 
		typeDesc-: Modules.TypeDesc; 
		scope-: Scope; 
		exit: BOOLEAN; 
		error-: BOOLEAN; 
		diagnostics: Diagnostics.Diagnostics; 
		context-: Commands.Context; 

		PROCEDURE ^  & Init*(scope: Scope; diagnostics: Diagnostics.Diagnostics; context: Commands.Context); 
		PROCEDURE ^ SetScope*(s: Scope); 
		PROCEDURE ^ Reset*; 
		PROCEDURE ^ Error(CONST msg: ARRAY OF CHAR); 
		PROCEDURE ^ ErrorSS(CONST msg: ARRAY OF CHAR; id: StringPool.Index); 
		PROCEDURE ^ {OVERRIDE} VisitSet*(x: SyntaxTree.Set); 
		PROCEDURE ^ {OVERRIDE} VisitMathArrayExpression*(x: SyntaxTree.MathArrayExpression); 
		PROCEDURE ^ NewInt(i: SIGNED64); 
		PROCEDURE ^ NewReal(i: FLOAT64); 
		PROCEDURE ^ NewBool(b: BOOLEAN); 
		PROCEDURE ^ NewSet(s: SET); 
		PROCEDURE ^ NewString(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ NewRange(r: RANGE); 
		PROCEDURE ^ NewChar(c: CHAR); 
		PROCEDURE ^ {OVERRIDE} VisitUnaryExpression*(x: SyntaxTree.UnaryExpression); 
		PROCEDURE ^ {OVERRIDE} VisitBinaryExpression*(x: SyntaxTree.BinaryExpression); 
		PROCEDURE ^ {OVERRIDE} VisitRangeExpression*(x: SyntaxTree.RangeExpression); 
		PROCEDURE ^ {OVERRIDE} VisitTensorRangeExpression*(x: SyntaxTree.TensorRangeExpression); 
		PROCEDURE ^ {OVERRIDE} VisitConversion*(x: SyntaxTree.Conversion); 
		PROCEDURE ^ {OVERRIDE} VisitDesignator*(x: SyntaxTree.Designator); 
		PROCEDURE ^ {OVERRIDE} VisitQualifiedType*(x: SyntaxTree.QualifiedType); 
		PROCEDURE ^ {OVERRIDE} VisitIdentifierDesignator*(x: SyntaxTree.IdentifierDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitSelectorDesignator*(x: SyntaxTree.SelectorDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitParameterDesignator*(x: SyntaxTree.ParameterDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitArrowDesignator*(x: SyntaxTree.ArrowDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitBracketDesignator*(x: SyntaxTree.BracketDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitSymbolDesignator*(x: SyntaxTree.SymbolDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitIndexDesignator*(x: SyntaxTree.IndexDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitProcedureCallDesignator*(x: SyntaxTree.ProcedureCallDesignator); 
		PROCEDURE ^ SystemTrace(x: SyntaxTree.ExpressionList); 
		PROCEDURE ^ FindType(type: SyntaxTree.Type): Result; 
		PROCEDURE ^ {OVERRIDE} VisitBuiltinCallDesignator*(x: SyntaxTree.BuiltinCallDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitTypeGuardDesignator*(x: SyntaxTree.TypeGuardDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitDereferenceDesignator*(x: SyntaxTree.DereferenceDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitSupercallDesignator*(x: SyntaxTree.SupercallDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitSelfDesignator*(x: SyntaxTree.SelfDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitResultDesignator*(x: SyntaxTree.ResultDesignator); 
		PROCEDURE ^ {OVERRIDE} VisitValue*(x: SyntaxTree.Value); 
		PROCEDURE ^ {OVERRIDE} VisitBooleanValue*(x: SyntaxTree.BooleanValue); 
		PROCEDURE ^ {OVERRIDE} VisitIntegerValue*(x: SyntaxTree.IntegerValue); 
		PROCEDURE ^ {OVERRIDE} VisitCharacterValue*(x: SyntaxTree.CharacterValue); 
		PROCEDURE ^ {OVERRIDE} VisitSetValue*(x: SyntaxTree.SetValue); 
		PROCEDURE ^ {OVERRIDE} VisitMathArrayValue*(x: SyntaxTree.MathArrayValue); 
		PROCEDURE ^ {OVERRIDE} VisitRealValue*(x: SyntaxTree.RealValue); 
		PROCEDURE ^ {OVERRIDE} VisitComplexValue*(x: SyntaxTree.ComplexValue); 
		PROCEDURE ^ {OVERRIDE} VisitStringValue*(x: SyntaxTree.StringValue); 
		PROCEDURE ^ {OVERRIDE} VisitNilValue*(x: SyntaxTree.NilValue); 
		PROCEDURE ^ {OVERRIDE} VisitEnumerationValue*(x: SyntaxTree.EnumerationValue); 
		PROCEDURE ^ {OVERRIDE} VisitSymbol*(x: SyntaxTree.Symbol); 
		PROCEDURE ^ {OVERRIDE} VisitTypeDeclaration*(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ {OVERRIDE} VisitConstant*(x: SyntaxTree.Constant); 
		PROCEDURE ^ {OVERRIDE} VisitVariable*(x: SyntaxTree.Variable); 
		PROCEDURE ^ {OVERRIDE} VisitParameter*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ {OVERRIDE} VisitProcedure*(x: SyntaxTree.Procedure); 
		PROCEDURE ^ {OVERRIDE} VisitBuiltin*(x: SyntaxTree.Builtin); 
		PROCEDURE ^ {OVERRIDE} VisitOperator*(x: SyntaxTree.Operator); 
		PROCEDURE ^ {OVERRIDE} VisitImport*(x: SyntaxTree.Import); 
		PROCEDURE ^ TranslateString*(cmd: CHAR; CONST str: ARRAY OF CHAR; VAR dest: Strings.String): BOOLEAN; 
		PROCEDURE ^ VisitCommandStatement(x: CommandStatement); 
		PROCEDURE ^ VisitPrintStatement(x: PrintStatement); 
		PROCEDURE ^ {OVERRIDE} VisitStatement*(x: SyntaxTree.Statement); 
		PROCEDURE ^ {OVERRIDE} VisitProcedureCallStatement*(x: SyntaxTree.ProcedureCallStatement); 
		PROCEDURE ^ LoadValue; 
		PROCEDURE ^ GetValue*(x: SyntaxTree.Expression; VAR w: Value): BOOLEAN; 
		PROCEDURE ^ Designate(x: SyntaxTree.Expression): Result; 
		PROCEDURE ^ Evaluate(x: SyntaxTree.Expression): Value; 
		PROCEDURE ^ GetInteger(x: SyntaxTree.Expression; VAR i: Integer): BOOLEAN; 
		PROCEDURE ^ ExpectInteger(x: SyntaxTree.Expression; VAR i: Integer): BOOLEAN; 
		PROCEDURE ^ GetBoolean(x: SyntaxTree.Expression; VAR i: Boolean): BOOLEAN; 
		PROCEDURE ^ ExpectBoolean(x: SyntaxTree.Expression; VAR b: Boolean): BOOLEAN; 
		PROCEDURE ^ PutValue(x: SyntaxTree.Expression; v: Value); 
		PROCEDURE ^ {OVERRIDE} VisitAssignment*(x: SyntaxTree.Assignment); 
		PROCEDURE ^ IfPart(ifPart: SyntaxTree.IfPart): BOOLEAN; 
		PROCEDURE ^ {OVERRIDE} VisitIfStatement*(x: SyntaxTree.IfStatement); 
		PROCEDURE ^ {OVERRIDE} VisitWithStatement*(x: SyntaxTree.WithStatement); 
		PROCEDURE ^ CasePart(x: SyntaxTree.CasePart; b: SyntaxTree.BinaryExpression): BOOLEAN; 
		PROCEDURE ^ {OVERRIDE} VisitCaseStatement*(x: SyntaxTree.CaseStatement); 
		PROCEDURE ^ {OVERRIDE} VisitWhileStatement*(x: SyntaxTree.WhileStatement); 
		PROCEDURE ^ {OVERRIDE} VisitRepeatStatement*(x: SyntaxTree.RepeatStatement); 
		PROCEDURE ^ {OVERRIDE} VisitForStatement*(x: SyntaxTree.ForStatement); 
		PROCEDURE ^ {OVERRIDE} VisitLoopStatement*(x: SyntaxTree.LoopStatement); 
		PROCEDURE ^ {OVERRIDE} VisitExitStatement*(x: SyntaxTree.ExitStatement); 
		PROCEDURE ^ {OVERRIDE} VisitReturnStatement*(x: SyntaxTree.ReturnStatement); 
		PROCEDURE ^ {OVERRIDE} VisitAwaitStatement*(x: SyntaxTree.AwaitStatement); 
		PROCEDURE ^ {OVERRIDE} VisitStatementBlock*(x: SyntaxTree.StatementBlock); 
		PROCEDURE ^ {OVERRIDE} VisitCode*(x: SyntaxTree.Code); 
		PROCEDURE ^ Expression(x: SyntaxTree.Expression); 
		PROCEDURE ^ Statement*(x: SyntaxTree.Statement); 
		PROCEDURE ^ StatementSequence*(x: SyntaxTree.StatementSequence); 
	END Interpreter; 

	Resolver* = OBJECT 
	VAR 
		interpreter: Interpreter; 
		content: PersistentObjects.Content; 
		resolved: Basic.HashTable; 
		current: Scope; 
		changed: BOOLEAN; 

		PROCEDURE ^  & InitResolver*; 
		PROCEDURE ^ Traverse(CONST name: ARRAY OF CHAR; array: BOOLEAN); 
		PROCEDURE ^ DoResolve*(scope: Scope); 
		PROCEDURE ^ Resolve*(scope: Scope); 
	END Resolver; 

	TestO = OBJECT 
	VAR 
		i: SIGNED32; 

		PROCEDURE ^  & P(s: SIGNED8); 
	END TestO; 

	; 
VAR 
	global-: Scope; 
	c: SIGNED32; 
	d: RECORD 
		e: SIGNED32; 
	END; 

	PROCEDURE ^ Statements*(context: Commands.Context); 
	PROCEDURE ^ Expression*(context: Commands.Context); 
	PROCEDURE ^ TranslateString*(context: Commands.Context); 
	PROCEDURE ^ InitGlobalScope; 
	PROCEDURE ^ Getter(): SIGNED32; 
	PROCEDURE ^ Setter(a: SIGNED32): SIGNED32; 
BEGIN
END FoxInterpreter.
